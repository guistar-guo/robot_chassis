/**
  ******************************************************************************
  * File Name          : aqmd.c
  * Description        : 爱思控485驱动
	* @author            : 天科大-机器人实验室-郭耀辉
  ******************************************************************************
  * @attention
  *
  * 本文件的协议解析是作者目前为止写过最复杂的！另外注意，目前板载的串口资源
	*	已经不够aqmd模块使用了，将代码加进工程只是为了后续改进ros通讯协议的时候作为
	* 参考，爱思控的协议参考：附件/通讯协议/AQMD6010BLS-Ex_UM_V0.90.pdf
  *
  ******************************************************************************
  */

#include "aqmd.h"

uint8_t GLOBLE_ADR;								//本次从站地址
uint8_t GLOBLE_READ_REG = READ_HOLD_REGISTER;								//本次接收校验寄存器
uint8_t aqmd_rec_buf[100];				//接收缓冲
uint8_t aqmd_rec_cur_cnt;					//记录接收缓冲区的有效数据个数
uint16_t rec_data;								//记录接收到的数据
uint16_t rec_data_crc;						//记录接收到的数据的crc校验值

uint16_t rec_send_reg;						//用于指示本次stm32给从机发送的寄存器
uint16_t rec_send_data;						//用于指示本次stm32给从机发送的数据

/* 高位字节的CRC 值*/ 
static unsigned char auchCRCHi[] = { 
 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 
 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 
 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 
 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 
 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 
 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 
 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 
 0x40 
} ; 
/* 低位字节的CRC 值*/ 
static char auchCRCLo[] = { 
 0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4, 
 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 
 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 
 0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3, 
 0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7, 
 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 
 0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26, 
 0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2, 
 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 
 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 
 0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5, 
 0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91, 
 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 
 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 
 0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C, 
 0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80, 
 0x40 
};

/**************************************************************************
函数功能：crc校验函数
入口参数：puchMsg：报头指针		usDataLen：报文长度
返回  值：crc校验结果
**************************************************************************/
static uint16_t CRC16(uint8_t *puchMsg, uint8_t usDataLen)
{      /* 函数以unsigned short 类型返回CRC */ 
 unsigned char uchCRCHi = 0xFF;   /* CRC 的高字节初始化*/ 
 unsigned char uchCRCLo = 0xFF;   /* CRC 的低字节初始化*/ 
 unsigned uIndex ;      /* CRC 查询表索引*/ 
 
 while (usDataLen--)      /* 完成整个报文缓冲区*/ 
 { 
  uIndex = uchCRCLo ^ *puchMsg++; /* 计算CRC */ 
  uchCRCLo = uchCRCHi ^ auchCRCHi[uIndex]; 
  uchCRCHi = auchCRCLo[uIndex]; 
 } 
 return (uchCRCHi << 8 | uchCRCLo); 
}

/**************************************************************************
函数功能：向485总线发送若干个字节
入口参数：略
返回  值：略
**************************************************************************/
static void aqmd_send_bytes(uint8_t * start, uint8_t size){
	HAL_UART_Transmit(&huart4, start, size, HAL_MAX_DELAY);
}

AqmdDataStateTypeDef aqmdDataState = undecided;
/**************************************************************************
函数功能：接收单个字节的回调函数
入口参数：本次接收到的字节
返回  值：无
**************************************************************************/
void aqmd_receive_one_byte_callback(uint8_t recByte){
		while(1){
			aqmd_rec_buf[aqmd_rec_cur_cnt] = recByte;
			if(aqmd_rec_cur_cnt == 0 && aqmd_rec_buf[0] != GLOBLE_ADR){//帧头不对，丢掉
				aqmdDataState = dataError;
				break;
			}
			aqmd_rec_cur_cnt++;
			
			if(GLOBLE_READ_REG == READ_HOLD_REGISTER){//如果是写保持寄存器
					if(aqmd_rec_cur_cnt == 2 && aqmd_rec_buf[1] != READ_HOLD_REGISTER){//异常码
						aqmdDataState = dataError;
						aqmd_rec_cur_cnt = 0;//重新开始读取
						break;
					}else if(aqmd_rec_cur_cnt == 2 && aqmd_rec_buf[1] == READ_HOLD_REGISTER){//未定码(因为还没有crc校验)
						aqmdDataState = undecided;
						break;
					}
					
					//计算crc校验值
					rec_data_crc = CRC16(aqmd_rec_buf, 5);
					if(aqmd_rec_cur_cnt == 7){
						if(((aqmd_rec_buf[6]<<8)|aqmd_rec_buf[5]) == rec_data_crc){//成功接收到一帧数据
							rec_data = (aqmd_rec_buf[3] << 8)|(aqmd_rec_buf[3]);//记录读取到的数据
							aqmdDataState = correct;//标记成功读取到了一帧数据
							aqmd_rec_cur_cnt = 0;//重新开始读取
						}else{//crc校验错误
							aqmdDataState = dataError;
							aqmd_rec_cur_cnt = 0;//重新开始读取
						}
						break;
					}
			}
			else if(GLOBLE_READ_REG == WRITE_SINGLE_REGISTER){//如果是写寄存器操作返回的数据
				if(aqmd_rec_cur_cnt == 2 && aqmd_rec_buf[1] != WRITE_SINGLE_REGISTER){//异常码
						aqmdDataState = dataError;
						aqmd_rec_cur_cnt = 0;//重新开始读取
						break;
				}else if(aqmd_rec_cur_cnt == 2 && aqmd_rec_buf[1] == WRITE_SINGLE_REGISTER){//未定码(因为还没有crc校验)
						aqmdDataState = undecided;
						break;
				}
				
				rec_data_crc = CRC16(aqmd_rec_buf, 6);//计算当前收到的所有数据的crc校验结果
				if(aqmd_rec_cur_cnt == 8){
					if(((aqmd_rec_buf[7]<<8)|aqmd_rec_buf[6]) == rec_data_crc){//成功接收到一帧数据
							rec_send_reg = ((aqmd_rec_buf[2]<<8)|aqmd_rec_buf[3]);//记录本次的寄存器地址
							rec_send_data = ((aqmd_rec_buf[4]<<8)|aqmd_rec_buf[5]);//记录本次的寄存器值
							aqmdDataState = correct;//标记成功读取到了一帧数据
							aqmd_rec_cur_cnt = 0;//重新开始读取
						}else{//crc校验错误
							aqmdDataState = dataError;
							aqmd_rec_cur_cnt = 0;//重新开始读取
						}
						break;
				}
			}
			break;
		}
}

//以下是一个标准的从站回送单字节的数据帧供测试程序使用
uint8_t test_rec[7]={0x00, 0x03, 0x03, 0x02, 0x03, 0x95, 0x25};

/**************************************************************************
函数功能：读取一个寄存器的数据
入口参数：ADR  从机地址	； addr 要读取的从机寄存器地址
返回  值：读取到的数据，错误码-1
**************************************************************************/
int aqmd_read_reg(uint8_t ADR, uint16_t addr){
	GLOBLE_ADR = ADR;
	GLOBLE_READ_REG = READ_HOLD_REGISTER;
	uint8_t send_temp[8] = {ADR, READ_HOLD_REGISTER, ((0Xff00 & addr)>>8), (0x00ff & addr), 0x00, 0x01, 0xff, 0xff};
	uint16_t send_data_crc_check = CRC16(send_temp, 6);
	send_temp[6] = (0x00ff & send_data_crc_check);
	send_temp[7] = ((0xff00 & send_data_crc_check)>>8);
	aqmd_send_bytes(send_temp, 8);
	uint16_t timeout = 0xffff;
	while(aqmdDataState != correct && timeout--){}
	aqmdDataState = undecided;//准备接收下一个字节
	return aqmdDataState == correct ? rec_data : -1;	
}

/**************************************************************************
函数功能：给爱思控的一个寄存器发送一个字节的数据
入口参数：ADR  从机地址	； addr 要写的从机寄存器地址；	data	要写的数据
返回  值：无
**************************************************************************/
void aqmd_send_one_byte_to_reg(uint8_t ADR, uint16_t addr, uint16_t data){
	GLOBLE_ADR = ADR;
	GLOBLE_READ_REG = WRITE_SINGLE_REGISTER;
	uint8_t send_temp[8] = {ADR, WRITE_SINGLE_REGISTER, ((0Xff00 & addr)>>8),\
	(0x00ff & addr), ((0Xff00 & data)>>8), (0x00ff & data), 0xff, 0xff};
	uint16_t send_data_crc_check = CRC16(send_temp, 6);
	send_temp[6] = (0x00ff & send_data_crc_check);
	send_temp[7] = ((0xff00 & send_data_crc_check)>>8);
	aqmd_send_bytes(send_temp, 8);
}

/**************************************************************************
函数功能：设置指定爱思控的pwm占空比
入口参数：ADR  从机地址	； pwm	输入范围-1000到1000，即占空比等于pwm*0.1
返回  值：无
**************************************************************************/
void aqmd_set_pwm(uint8_t ADR, short pwm){
	aqmd_send_one_byte_to_reg(ADR, REG_SET_PWM, pwm);
}

/**************************************************************************
函数功能：打印调试信息
入口参数：无
返回  值：无
**************************************************************************/
void aqmd_debug_log(void){
		for (int i = 0; i<10; i++){
			rtos_printf("0x%x ", aqmd_rec_buf[i]);
		}
		rtos_printf("\r\n");
		
		switch(aqmdDataState){
			case undecided:
				rtos_printf("undecided\r\n");
				break;
			case dataError:
				rtos_printf("dataError\r\n");
				break;
			case correct:
				rtos_printf("correct\r\n");
				break;
		}
		
		osDelay(200);
}

//测试使用
void aqmd_test(void){
	while(1){
		aqmd_set_pwm(0x01, 500);
		osDelay(2000);
		aqmd_set_pwm(0x01, 0);
		osDelay(500);
		aqmd_set_pwm(0x01, -500);
		osDelay(2000);
		aqmd_set_pwm(0x01, 0);
		osDelay(500);
		
//		aqmd_debug_log();
//		osDelay(200);
	}
}
























